---
layout: single
title:  "Coroutine의 기본 개념"
categories:
  - blog
sidebar:
  nav: sidebar-category
---

---

# 코루틴 vs 스레드 비교 및 분석

## 1. 서론
코틀린에서 비동기 프로그래밍을 다룰 때 `Coroutine`은 핵심적인 개념이다. 많은 개발자들이 스레드와 코루틴의 차이를 혼동하는 경우가 많다. 이번 글에서는 스레드와 코루틴의 차이를 비교하고, 코루틴이 왜 강력한지 알아보겠다.

## 2. 스레드 vs 코루틴

### 2.1 스레드(Thread)
스레드는 운영체제가 관리하는 실행 단위이며, 하나의 프로세스 내에서 여러 개의 스레드가 동작할 수 있다. 하지만 스레드는 몇 가지 단점을 가지고 있다.

- **무거운 리소스 사용**: 스레드는 생성 및 컨텍스트 스위칭 시 높은 비용이 발생한다.
- **제어가 어렵다**: 스레드 간 동기화가 어렵고, 데드락과 같은 문제가 발생할 수 있다.
- **운영체제(OS) 의존적**: 스레드는 운영체제에서 직접 관리되므로 스케줄링과 컨텍스트 스위칭에 대한 제어가 제한적이다.

### 2.2 플랫폼 스레드 vs 커널 스레드
스레드는 크게 플랫폼 스레드와 커널 스레드로 나뉜다.

- **커널 스레드(Kernel Thread)**: 운영체제 커널이 직접 관리하는 스레드로, OS 스케줄러가 실행을 제어한다. 컨텍스트 스위칭 시 높은 오버헤드가 발생한다.
- **플랫폼 스레드(Platform Thread)**: JVM이 운영체제의 기본 스레드 모델을 따르며, 일반적으로 커널 스레드 위에서 동작한다. 코틀린에서 일반적인 스레드는 플랫폼 스레드로 작동한다.

### 2.3 컨텍스트 스위칭(Context Switching)
컨텍스트 스위칭은 CPU가 현재 실행 중인 작업을 중단하고 다른 작업으로 전환하는 과정이다. 운영체제에서 멀티태스킹을 지원하기 위해 필수적인 과정이지만, 오버헤드가 크기 때문에 성능 저하의 주요 원인이 된다.

#### 컨텍스트 스위칭 과정
1. 현재 실행 중인 스레드의 상태를 저장한다.
2. 새로운 스레드를 위한 상태 정보를 로드한다.
3. CPU가 새로운 스레드를 실행하도록 전환한다.

#### 컨텍스트 스위칭의 문제점
- **높은 비용**: CPU 레지스터, 메모리, 스택 등 다양한 정보를 저장하고 복원하는 과정에서 성능이 저하된다.
- **캐시 미스(Cache Miss)**: 새로운 작업으로 전환될 때 캐시가 비효율적으로 사용될 가능성이 높다.
- **멀티스레딩 환경에서 증가하는 부하**: 많은 스레드가 존재할수록 컨텍스트 스위칭이 더 빈번해지며 시스템 리소스를 낭비할 수 있다.

### 2.4 코루틴(Coroutine)
코루틴은 경량 스레드라고도 불리며, 스레드보다 더 효율적으로 비동기 작업을 수행할 수 있다.

- **경량성**: 스레드보다 적은 비용으로 생성 및 실행할 수 있다.
- **논블로킹 방식**: 특정 작업을 수행하는 동안 다른 작업을 블로킹하지 않는다.
- **협력적 멀티태스킹**: 코루틴은 필요할 때만 실행되며, 명시적으로 중단 및 재개가 가능하다.
- **제어가 용이함**: `suspend` 키워드를 사용하여 쉽게 중단 및 재개할 수 있다.
- **컨텍스트 스위칭 비용 절감**: OS 차원의 컨텍스트 스위칭이 아닌, 사용자 수준에서 컨트롤할 수 있는 방식으로 오버헤드를 줄일 수 있다.

### 2.5 구조적 동시성(Structured Concurrency)
구조적 동시성은 코루틴을 효과적으로 관리할 수 있도록 돕는 개념으로, 부모 코루틴의 생명주기에 따라 자식 코루틴이 관리되는 방식을 의미한다. 이를 통해 예측 가능한 코드 흐름과 오류 처리가 가능하다.

- **자동 정리**: 부모 코루틴이 취소되면, 그에 속한 모든 자식 코루틴도 함께 취소된다.
- **범위(Scope) 관리**: `CoroutineScope`를 활용하여 실행 단위를 제한할 수 있다.
- **예외 전파**: 자식 코루틴에서 발생한 예외가 부모 코루틴으로 전파되어 효과적으로 예외를 처리할 수 있다.

```kotlin
fun main() = runBlocking {
    val job = launch {
        delay(1000)
        println("Child coroutine completed")
    }
    println("Waiting for coroutine to finish...")
    job.join()
    println("Done")
}
```

## 3. 주요 차이점 비교
| 구분 | 스레드(Thread) | 코루틴(Coroutine) |
|------|---------------|----------------|
| 실행 단위 | 운영체제에서 관리 | 사용자 레벨에서 관리 |
| 컨텍스트 스위칭 비용 | 높음 | 낮음 |
| 동기화 | 필요 (락, 동기화 도구 사용) | 필요 없음 (suspend 기능 활용) |
| 생성 속도 | 상대적으로 느림 | 빠름 |
| 리소스 사용 | 많음 | 적음 |
| 제어 방식 | OS에서 스케줄링 | 개발자가 직접 제어 |

## 4. 결론
스레드는 운영체제에서 직접 관리되는 무거운 실행 단위이며, 멀티스레딩을 관리하기 어렵다. 반면, 코루틴은 가벼운 실행 단위로 비동기 프로그래밍을 보다 쉽게 구현할 수 있다. 또한, 코루틴은 OS 기반의 컨텍스트 스위칭을 줄여서 성능을 향상시킨다. 

특히 구조적 동시성을 활용하면 예측 가능한 동시성 프로그래밍이 가능해지고, 자식 코루틴을 효과적으로 관리할 수 있다. 따라서 코틀린에서 비동기 작업을 처리할 때는 가급적 코루틴을 사용하는 것이 효율적이다.

