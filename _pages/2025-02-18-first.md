# 면접 Q&A 종합 정리: Redis 기반 찜하기 시스템, Pending Data, 및 LLM 추천 시스템

아래는 Redis 기반 찜하기 기능 구현 설계, 키 구조와 자료구조 선정, Write-Back(Pending Data) 방식, 그리고 LLM을 활용한 추천 시스템 구축에 관한 면접 질문과 예시 답변들을 통합한 내용입니다.  
면접 시, 본인의 경험과 구체적인 사례(트래픽, 인프라 환경, 운영 전략 등)를 덧붙여 설명하면 좋은 인상을 줄 수 있습니다.

---

## 1. 기본 설계 및 Redis 도입 배경

### Q1. 찜하기 기능을 RDB 대신 Redis로 관리하겠다고 했는데, 왜 그렇게 결정하셨나요?
**A.**  
- **조회 빈도**가 매우 높고, 사용자별 찜 목록이 실시간으로 빠르게 조회되어야 하기 때문입니다.
- Redis는 **메모리 기반**으로 동작하여 디스크 I/O 없이 빠른 응답을 제공합니다.
- 또한, 단일 스레드 구조와 이벤트 루프로 락 경합을 줄이고, 대규모 트래픽에서도 안정적인 성능을 보장합니다.
- RDB만으로 구현하면 트래픽 증가 시 DB 부하가 커지므로, Redis를 캐시 및 실시간 데이터 저장소로 활용하고 MySQL 등 원본 DB와 Write-Back 구조를 병행합니다.

### Q2. 찜 데이터를 Redis에만 완전히 저장하면, 장애 시 데이터 유실 위험은 어떻게 보완할 건가요?
**A.**  
- Redis는 인메모리 DB이기 때문에 장애 시 데이터 유실 위험이 있습니다.
- 이를 보완하기 위해 **Write-Back(또는 Write-Through)** 방식으로 주기적으로 MySQL에 동기화(스케줄러/배치)를 수행하여 원본을 보관합니다.
- 장애 발생 후 재부팅 시, RDB의 원본 데이터를 기반으로 Redis를 재적재할 수 있습니다.

---

## 2. 키 구조 및 자료구조 선정

### Q3. 유저별 찜 목록을 빠르게 조회하려면 어떤 자료구조와 키 설계를 사용하셨나요?
**A.**  
- 기본적으로 **Set** 자료구조를 사용합니다.
- `wishlist:user:{userId}` 키에 해당 유저가 찜한 itemId들을 저장하며, `SADD`와 `SMEMBERS` 명령어로 관리합니다.
- 이 방식은 “사용자 A가 찜한 상품”을 빠르게 조회할 수 있도록 해 줍니다.

### Q4. 상품별로 찜 개수나 "누가 찜했는지"를 보려면 어떻게 하나요?
**A.**  
- 상품별로도 Set을 추가 운영하여, `wishlist:item:{itemId}` 키에 찜한 유저ID들을 저장합니다.
- 이를 통해 `SCARD`로 찜 개수를, `SMEMBERS`로 찜 유저 목록을 즉시 조회할 수 있습니다.
- 다만, 양방향 저장을 사용할 경우 메모리 사용량과 동시 업데이트 시 **정합성** 유지에 주의해야 합니다.

### 대규모 데이터 저장 문제 및 대안
- 만약 인기 상품이 100만 개의 상품 중 1000개씩 찜되어 총 10억 건 이상의 유저 데이터가 발생한다면, 일반 Set 방식은 메모리 부담이 커집니다.
- **대안:**  
  - **단순 카운트 관리:** 찜 개수만 `INCR/DECR` 명령어로 관리하는 방법 (단, 유저 목록 정보는 사라짐).
  - **압축 비트맵 (Roaring Bitmap):**  
    - 유저 목록이 반드시 필요하다면, Roaring Bitmap 같은 압축 자료구조를 활용하여 메모리 사용량을 줄이면서도 유저 ID 집합을 효율적으로 저장할 수 있습니다.
    - 이를 위해 Redis 모듈이나 애플리케이션 레벨 직렬화/역직렬화 방식을 사용할 수 있습니다.

---

## 3. 만료 정책 (예: 1년 보관 후 삭제)

### Q5. Redis에서 개별 원소에 TTL 설정이 어렵다는 문제를 어떻게 해결하나요?
**A.**  
- Redis는 **키 단위**로 TTL을 지원하므로, Set 내부 원소마다 TTL을 설정할 수 없습니다.
- 대신, RDB에서 1년 지난 찜 데이터를 배치로 조회·삭제한 후, Redis에서도 해당 (user, item) 관계를 `SREM` 명령어로 제거하는 방식을 사용합니다.
- 이렇게 하면 전체 데이터가 아닌 만료 대상만 효율적으로 삭제할 수 있습니다.

### Q6. 배치로 만료 시, 대량의 `SREM` 작업으로 인한 Redis 부하는 어떻게 제어하나요?
**A.**  
- 배치는 트래픽이 적은 시간(예: 새벽)으로 스케줄링합니다.
- 한 번에 너무 많은 작업이 몰리지 않도록 페이지 단위로 분할 처리하고, **파이프라인(Pipeline)**을 사용해 다수의 `SREM` 명령어를 묶어서 실행합니다.

---

## 4. 정합성 및 트랜잭션

### Q7. 찜 등록 시, 유저별 Set과 상품별 Set을 동시에 업데이트하는데, 한쪽만 갱신되는 경우는 어떻게 처리하나요?
**A.**  
- Redis의 **MULTI/EXEC** 트랜잭션이나 파이프라인을 사용하여 두 작업을 원자적으로 처리합니다.
- 에러 발생 시 재시도 또는 보정 로직을 마련하여, 유저별과 상품별 데이터 간의 불일치를 해결합니다.
- 주기적으로 MySQL 원본과 Redis 데이터를 비교해 불일치가 있으면 보정하는 배치 작업도 운영합니다.

---

## 5. 성능 및 확장성

### Q8. 대규모 트래픽(수십만 동시 접속) 환경에서 Redis 기반 찜하기 시스템의 확장성은 어떻게 보장하나요?
**A.**  
- Redis는 초당 수십만~수백만 건의 간단 연산을 처리할 수 있습니다.
- 데이터와 요청이 매우 많을 경우 **Redis Cluster**(샤딩)를 통해 여러 노드에 분산시켜 확장할 수 있습니다.
- 또한, Write-Back 구조를 통해 RDB 부하를 분산시키며 전체 시스템의 확장성을 확보합니다.

### Q9. 상품별 명단이 엄청 커질 경우(예: 수백만 유저가 찜), Redis 메모리 부족 문제는 어떻게 대응하나요?
**A.**  
- 모든 상품에 대해 양방향 Set을 운영하면 메모리 사용량이 급증할 수 있습니다.
- 이 경우, 자주 조회되는 상품에 대해서만 상세 유저 목록을 저장하고, 나머지는 **카운트 키** 또는 **압축 자료구조(예: Roaring Bitmap)**를 사용해 메모리 사용량을 최적화합니다.
- 정기적인 만료 배치와 불필요한 데이터 제거로 메모리 최적화도 병행합니다.

---

## 6. 응용 및 확장 기능

### Q10. “최근 본 상품”, “장바구니” 등 다른 개인화 기능에도 이 구조를 적용할 수 있나요?
**A.**  
- 네, “유저별 Set” 또는 “Sorted Set” 같은 구조는 다른 개인화 기능(최근 본 상품, 즐겨찾기, 검색어 등)에도 유사하게 적용할 수 있습니다.
- 단, 각 기능마다 보관 기간, 접근 방식, 자료구조가 다를 수 있으므로 키 네이밍과 만료 정책을 별도로 관리합니다.

### Q11. 찜 데이터를 기반으로 개인화 추천(머신러닝)이나 통계 분석을 어떻게 진행할 건가요?
**A.**  
- Redis에는 빠른 조회를 위해 최소한의 유저-아이템 관계만 저장하고, 자세한 로그나 클릭 이력은 데이터 웨어하우스(MySQL, BigQuery, Hadoop 등)에 적재하여 분석합니다.
- 이를 바탕으로 협업 필터링, 행렬 분해, 딥러닝 기반 추천 모델을 구축하고, 주기적으로 모델을 학습시켜 추천 결과에 반영합니다.
- 실시간 추천이 필요하면 Kafka 같은 메시지 큐를 통해 이벤트를 쌓고, 소비/분석 파이프라인을 구성할 수 있습니다.

---

## 7. LLM을 활용한 추천 시스템 구현

### Q12. 빅데이터 기반 분석 대신 LLM을 활용하여 추천 시스템을 구현할 수 있을까요?
**A.**  
- 네, LLM(대형 언어 모델)을 활용하면 상품 설명, 사용자 리뷰, 찜한 아이템의 텍스트 데이터를 분석해 사용자의 취향을 자연어 수준으로 이해할 수 있습니다.
- **구현 예시:**
  1. **데이터 준비:** Redis의 찜 데이터와 상품 메타데이터(제목, 설명, 카테고리 등)를 수집합니다.
  2. **프롬프트 설계 및 추천 생성:**  
     - “사용자 A의 찜 목록은 [상품 목록 및 특징 요약]입니다. 이 사용자와 비슷한 스타일의 신상품을 추천해 주세요.”  
     - LLM은 이를 기반으로 추천 상품과 그 추천 이유를 자연어로 생성합니다.
  3. **후보군 재정렬:**  
     - 기존 협업 필터링 또는 인기순 추천 후보군을 LLM을 통해 재정렬하거나 보완합니다.
- **고려 사항:** LLM API 비용, 응답 지연, 데이터 프라이버시 및 캐싱 전략 등을 함께 고려해야 합니다.

---

## 8. 종합 통합 시나리오

### Q13. 전체 시스템에서 Redis, Pending Data, 그리고 LLM을 활용한 추천 시스템이 어떻게 유기적으로 작동하는지 설명해 주세요.
**A.**  
- **실시간 데이터 관리:**  
  - 사용자가 찜 등록/취소하면, Redis의 `wishlist:user:{userId}`와 `wishlist:item:{itemId}`에 즉시 반영되고,  
  - 변경 내역은 Pending Data(예: `dibs:pending` 리스트)에 기록됩니다.
- **증분 동기화:**  
  - 스케줄러가 5분마다 Pending Data 로그를 읽어, 변경된 데이터만 MySQL 등 원본 DB에 업데이트합니다.
- **추천 파이프라인:**  
  - 오프라인 배치나 실시간 이벤트 스트림을 통해 사용자-상품 매트릭스를 생성하고,  
  - 기존 협업 필터링과 함께 LLM을 활용해 자연어 기반 추천(예: 프롬프트에 사용자의 찜 목록과 상품 설명을 입력하여 추천 생성)을 수행하여 후보군을 산출, 재정렬합니다.
- **최종 서빙:**  
  - 추천 결과는 Redis나 별도 캐시 시스템에 저장되어, 사용자가 빠르게 개인화 추천 상품을 확인할 수 있도록 합니다.

---

# 결론

면접에서는 아래 핵심 포인트를 강조할 수 있어야 합니다.

- **Redis 도입 배경:**  
  - 메모리 기반의 빠른 조회, 락 경합 최소화, 대규모 트래픽 처리 능력.
- **키 구조 및 자료구조 선정:**  
  - 유저별 Set(`wishlist:user:{userId}`)과 상품별 Set(`wishlist:item:{itemId}`)을 통해 양방향 조회를 구현하되,  
  - 대규모 데이터의 경우 압축 자료구조(예: Roaring Bitmap)를 고려하여 메모리 효율을 최적화.
- **Write-Back 및 Pending Data:**  
  - 변경점(증분)만 MySQL에 동기화하여 전체 업데이트의 비효율을 줄임.
- **만료 정책:**  
  - 개별 원소 TTL 대신, 배치 작업과 Redis `SREM` 명령을 활용한 증분 삭제 방식.
- **추천 시스템:**  
  - 협업 필터링, 통계 기반 모델과 함께 LLM을 활용해 자연어 기반 추천 및 설명 제공.
- **통합 아키텍처:**  
  - Redis를 통한 실시간 데이터 관리, Pending Data 기반 증분 동기화, 그리고 LLM 기반 추천 시스템이 유기적으로 결합되어, 빠르고 정확한 개인화 추천 서비스를 제공.

이와 같이 본인의 경험과 구체적인 구현 사례를 바탕으로 답변하면, 면접관에게 깊은 인상을 줄 수 있을 것입니다.
